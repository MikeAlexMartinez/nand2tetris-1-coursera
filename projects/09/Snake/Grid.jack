
/**
 *  accessible grid for snake is:
 *  14 * 16px high
 *  30 * 16px wide
 */
class Grid {

  field int height;
  field int width;

  constructor Grid new() {
    do drawGrid();
    do drawSnake();
    return this;
  }

  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }

  method void drawGrid() {
    do drawVertical(-1, 8); // Left side
    do drawVertical(-1, 31); // right side
    do drawHorizontal(-1, 0, 9, 21, 16); // top side
    do drawHorizontal(-1, 239, 9, 21, 16); // bottom side
    return;
  }

  /* starts snake as 5 blocks of 8 by 8 pixels */
  method void drawSnake() {
    do drawHorizontal(-1, 112, 14, 5, 16); // Snake Start
    return;
  }

  /**
   * returns int that represents whether snake will encounter
   * an object when completing next move.
   * 0 = nothing
   * 1 = tail
   * 2 = wall
   * 3 = food
   */
  method int detectCollision(Array head) {
    var int collision;

    let collision = 0;
    // if col or row outside boundary return 2

    // else inside,
    //    check tail
    //        return 1
    //    check food
    //        return 
    return collision;
  }

  method void updateSnake(Array head, Array tail) {
    return;
  }

  method void setFood() {
    var int col, row;
    var boolean hasSnake;
    var boolean foodDrawn;

    let foodDrawn = false;
    let hasSnake = false;
    while(~(foodDrawn)) {
      // generate location using randRange
      let col = LCGRandom.randRange(0, 19);
      let row = LCGRandom.randRange(0, 13);
      // if selected range has snake, regen
      let hasSnake = cellHasSnake(col, row);
      // drawFood
      if (~hasSnake) {
        do drawFood(col, row);
      }
    }
    return;
  }

  method boolean cellHasSnake(int col, int row) {
    var int memAddress, val;
    let row = row + 16;
    let col = col + 9;
    let memAddress = 16384 + col + (32 * row) - 1;
    let val = Memory.peek(memAddress);
    return (val = -1)
  }

  method void drawFood(int col, int row) {

  }

  /* draw the sides of the snake container */
  method void drawVertical(int value, int column) {
    var int memAddress, start, end;
    var int increment, diff;

    let memAddress = 16384 + column;
    let start = 0;
    let end = 255;
    let increment = 32;
    let diff = start * increment;

    while(~(start > end)) {
      do Memory.poke(memAddress + diff, value);
      let start = start + 1;
      let diff = diff + increment;
    }

    return;
  }

  method void drawHorizontal(int value, int row, int colStart, int cols, int height) {
    var int memAddress; // active memory address
    var int start, end; // number of rows
    var int col, colEnd; // number of columns

    let start = row;
    let end = start + height;
    let col = colStart;
    let colEnd = col + cols;

    // do column
    while(~(start > end)) {
      let memAddress = 16384 + col + (32 * start) - 1;

      // do row
      while(~(col > colEnd)) {
        let memAddress = memAddress + 1;
        do Memory.poke(memAddress, value);
        let col = col + 1;
      }

      // reset column
      let col = colStart;

      // increment starting point
      let start = start + 1;
    }

    return;
  }
}